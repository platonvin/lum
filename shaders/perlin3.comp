#version 450 core

precision highp int;
precision highp float;

layout(set = 0, binding = 0, rgba16) uniform image3D noise_image;

/**
An implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds
inspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider
(Guerrilla Games). The first column is the perlin-worley noise generated by remapping
perlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms
with increasing frequencies, and are used to model the cloud shapes which are rendered
in the last column. See the common tab for all the noise functions used.
*/

// Hash by David_Hoskins
#define UI0 1597334673U
#define UI1 3812015801U
#define UI2 uvec2(UI0, UI1)
#define UI3 uvec3(UI0, UI1, 2798796415U)
#define UIF (1.0 / float(0xffffffffU))

vec3 hash33(vec3 p)
{
	uvec3 q = uvec3(ivec3(p)) * UI3;
	q = (q.x ^ q.y ^ q.z)*UI3;
	return -1. + 2. * vec3(q) * UIF;
}

float remap(float x, float a, float b, float c, float d)
{
    return (((x - a) / (b - a)) * (d - c)) + c;
}

// Gradient noise by iq (modified to be tileable)
float gradientNoise(vec3 x, float freq)
{
    // grid
    vec3 p = floor(x);
    vec3 w = fract(x);
    
    // quintic interpolant
    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);

    
    // gradients
    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));
    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));
    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));
    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));
    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));
    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));
    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));
    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));
    
    // projections
    float va = dot(ga, w - vec3(0., 0., 0.));
    float vb = dot(gb, w - vec3(1., 0., 0.));
    float vc = dot(gc, w - vec3(0., 1., 0.));
    float vd = dot(gd, w - vec3(1., 1., 0.));
    float ve = dot(ge, w - vec3(0., 0., 1.));
    float vf = dot(gf, w - vec3(1., 0., 1.));
    float vg = dot(gg, w - vec3(0., 1., 1.));
    float vh = dot(gh, w - vec3(1., 1., 1.));
	
    // interpolation
    return va + 
           u.x * (vb - va) + 
           u.y * (vc - va) + 
           u.z * (ve - va) + 
           u.x * u.y * (va - vb - vc + vd) + 
           u.y * u.z * (va - vc - ve + vg) + 
           u.z * u.x * (va - vb - ve + vf) + 
           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
}

// Tileable 3D worley noise
float worleyNoise(vec3 uv, float freq)
{    
    vec3 id = floor(uv);
    vec3 p = fract(uv);
    
    float minDist = 10000.;
    for (float x = -1.; x <= 1.; ++x)
    {
        for(float y = -1.; y <= 1.; ++y)
        {
            for(float z = -1.; z <= 1.; ++z)
            {
                vec3 offset = vec3(x, y, z);
            	vec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;
    			h += offset;
            	vec3 d = p - h;
           		minDist = min(minDist, dot(d, d));
            }
        }
    }
    
    // inverted worley noise
    return 1. - minDist;
}

// Fbm for Perlin noise based on iq's blog
float perlinfbm(vec3 p, float freq, int octaves)
{
    float G = exp2(-.85);
    float amp = 1.;
    float noise = 0.;
    for (int i = 0; i < octaves; ++i)
    {
        noise += amp * gradientNoise(p * freq, freq);
        freq *= 2.;
        amp *= G;
    }
    
    return noise;
}

// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes
// chapter in GPU Pro 7.
float worleyFbm(vec3 p, float freq)
{
    return worleyNoise(p*freq, freq) * .625 +
        	 worleyNoise(p*freq*2., freq*2.) * .25 +
        	 worleyNoise(p*freq*4., freq*4.) * .125;
}

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
void main(){
	 vec3 fpix = gl_GlobalInvocationID.xyz + 0.5;
	ivec3 ipix = ivec3(fpix);
	// float noise_val = cnoise(fpix / 48.0); 
	vec4 noise_val; 
    float freq = 3.0;

    noise_val.x = worleyFbm(fpix/32.0, freq); 
    noise_val.y = worleyFbm(fpix/32.0, freq*2.0); 
    noise_val.z = worleyFbm(fpix/32.0, freq*4.0); 
    noise_val.w = worleyFbm(fpix/32.0, freq*8.0); 
// mult
	imageStore(noise_image, ipix, vec4(noise_val));
}


// // implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a 
// // single unsigned integer.

// uint hash(uint x, uint seed) {
//     const uint m = 0x5bd1e995U;
//     uint hash = seed;
//     // process input
//     uint k = x;
//     k *= m;
//     k ^= k >> 24;
//     k *= m;
//     hash *= m;
//     hash ^= k;
//     // some final mixing
//     hash ^= hash >> 13;
//     hash *= m;
//     hash ^= hash >> 15;
//     return hash;
// }

// // implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  
// // 3-dimensional unsigned integer input vector.

// uint hash(uvec3 x, uint seed){
//     const uint m = 0x5bd1e995U;
//     uint hash = seed;
//     // process first vector element
//     uint k = x.x; 
//     k *= m;
//     k ^= k >> 24;
//     k *= m;
//     hash *= m;
//     hash ^= k;
//     // process second vector element
//     k = x.y; 
//     k *= m;
//     k ^= k >> 24;
//     k *= m;
//     hash *= m;
//     hash ^= k;
//     // process third vector element
//     k = x.z; 
//     k *= m;
//     k ^= k >> 24;
//     k *= m;
//     hash *= m;
//     hash ^= k;
// 	// some final mixing
//     hash ^= hash >> 13;
//     hash *= m;
//     hash ^= hash >> 15;
//     return hash;
// }


// vec3 gradientDirection(uint hash) {
//     switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction
//     case 0:
//         return vec3(1, 1, 0);
//     case 1:
//         return vec3(-1, 1, 0);
//     case 2:
//         return vec3(1, -1, 0);
//     case 3:
//         return vec3(-1, -1, 0);
//     case 4:
//         return vec3(1, 0, 1);
//     case 5:
//         return vec3(-1, 0, 1);
//     case 6:
//         return vec3(1, 0, -1);
//     case 7:
//         return vec3(-1, 0, -1);
//     case 8:
//         return vec3(0, 1, 1);
//     case 9:
//         return vec3(0, -1, 1);
//     case 10:
//         return vec3(0, 1, -1);
//     case 11:
//         return vec3(0, -1, -1);
//     case 12:
//         return vec3(1, 1, 0);
//     case 13:
//         return vec3(-1, 1, 0);
//     case 14:
//         return vec3(0, -1, 1);
//     case 15:
//         return vec3(0, -1, -1);
//     }
// }

// float interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {
//     return mix(
//         mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),
//         mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),
//         t.z
//     );
// }

// vec3 fade(vec3 t) {
//     // 6t^5 - 15t^4 + 10t^3
// 	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
// }

// float perlinNoise(vec3 position, uint seed) {
//     vec3 floorPosition = floor(position);
//     vec3 fractPosition = position - floorPosition;
//     uvec3 cellCoordinates = uvec3(floorPosition);
//     float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);
//     float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));
//     float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));
//     float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));
//     float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));
//     float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));
//     float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));
//     float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));
//     return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));
// }

// float perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {
//     float value = 0.0;
//     float amplitude = 1.0;
//     float currentFrequency = float(frequency);
//     uint currentSeed = seed;
//     for (int i = 0; i < octaveCount; i++) {
//         currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave
//         value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;
//         amplitude *= persistence;
//         currentFrequency *= lacunarity;
//     }
//     return value;
// }

// // void mainImage(out vec4 fragColor, in vec2 fragCoord) {
// //     vec2 position = fragCoord / iResolution.xy;
// //     position.x *= iResolution.x / iResolution.y;
// //     uint seed = 0x578437adU; // can be set to something else if you want a different set of random values
// //     // float frequency = 16.0;
// //     // float value = perlinNoise(vec3(position, iTime * 0.25) * frequency, seed); // single octave perlin noise
// //     float value = perlinNoise(vec3(position, iTime * 0.25), 1, 6, 0.5, 2.0, seed); // multiple octaves
// //     value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]
// //     fragColor = vec4(vec3(value), 1.0);
// // }

// layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
// void main(){
// 	 vec3 fpix = gl_GlobalInvocationID.xyz + 0.5;
// 	ivec3 ipix = ivec3(fpix);
// 	// float noise_val = cnoise(fpix / 48.0); 
// 	vec4 noise_val; 
//     noise_val.x = perlinNoise(fpix/32.0, 1, 6, 0.5, 2.0, 0); 
//     noise_val.y = perlinNoise(fpix/32.0, 1, 6, 0.5, 2.0, 1); 
//     noise_val.z = perlinNoise(fpix/32.0, 1, 6, 0.5, 2.0, 2); 
//     noise_val.w = perlinNoise(fpix/32.0, 1, 6, 0.5, 2.0, 3); 
// // mult
// 	imageStore(noise_image, ipix, vec4(noise_val));
// }
